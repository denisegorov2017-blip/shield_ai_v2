# Техническое исследование: Парсинг иерархических Excel-файлов

## 1. Выбор библиотеки для парсинга

### Decision (Решение)
Использовать библиотеку **`openpyxl`** в режиме `read-only` с итеративным чтением строк (`ws.iter_rows()`).

### Rationale (Обоснование)
-   **Производительность и память:** `openpyxl` в режиме `read-only` позволяет обрабатывать Excel-файлы любого размера с почти константным потреблением памяти. Это достигается за счет того, что файл не загружается в память целиком, а читается итеративно, строка за строкой. Это критически важно для обработки больших отчетов.
-   **Работа с неструктурированными данными:** В отличие от `pandas`, который ориентирован на табличные данные, `openpyxl` предоставляет низкоуровневый доступ к структуре листа, включая ячейки, их стили, объединенные диапазоны и другие метаданные. Этот уровень детализации необходим для надежного распознавания иерархических заголовков, групп и итоговых строк, которые часто встречаются в сложных отчетах.
-   **Гибкость API:** API `openpyxl` позволяет реализовать сложную логику парсинга, основанную на состоянии (конечный автомат), где каждая строка анализируется в контексте предыдущих.

### Alternatives considered (Рассмотренные альтернативы)
-   **`pandas`:** Мощный инструмент для анализа данных, но плохо подходит для парсинга *неструктурированных* отчетов. `pandas` предполагает, что данные организованы в виде плоской таблицы. При чтении иерархических файлов он может терять информацию о форматировании, объединенных ячейках и многоуровневых заголовках, что делает невозможным восстановление контекста. Хотя `pandas` поддерживает итеративное чтение (`chunksize`), он не предоставляет такого гранулярного контроля над ячейками, как `openpyxl`.
-   **`xlrd`:** Ранее популярная библиотека, но сейчас она поддерживает только старый формат `.xls`. Для современных файлов `.xlsx` она не подходит.

## 2. Стратегия распознавания типов строк

### Decision (Решение)
Реализовать многоуровневую стратегию, комбинирующую анализ содержимого, структуры и форматирования ячеек.

### Rationale (Обоснование)
Иерархические отчеты не имеют строгой схемы, поэтому для надежного распознавания требуется комбинация методов:

1. **Паттерны и регулярные выражения:** Использовать для поиска ключевых слов-маркеров, таких как "Склад", "Итого", "Документ", "№". Это самый надежный способ идентификации строк-заголовков и итогов.
2.  **Структурные эвристики:**
    -   **Строка-заголовок уровня:** Часто содержит значение только в одной из первых ячеек, а остальные пустые.
    -   **Строка данных:** Содержит значения в определенном наборе колонок (например, артикул, количество, цена, сумма).
    -   **Пустая строка-разделитель:** Все ячейки в строке пусты (`value is None`).
3.  **Анализ форматирования (через `openpyxl`):** Заголовки и итоговые строки часто имеют уникальное форматирование (жирный шрифт, курсив, цвет фона), которое можно использовать как дополнительный признак для классификации.

Этот подход обеспечивает гибкость и устойчивость к небольшим изменениям в структуре отчета.

### Alternatives considered (Рассмотренные альтернативы)
-   **Жестко заданные номера строк:** Ненадежный подход, так как структура отчета может меняться, количество строк данных динамическое.
-   **Исключительно регулярные выражения:** Недостаточно гибко, так как не все типы строк можно описать четким паттерном (например, строки данных).

## 3. Реализация "контекстного стека"

### Decision (Решение)
Использовать конечный автомат (State Machine) в паре со стеком для управления текущим иерархическим контекстом.

### Rationale (Обоснование)
Этот паттерн идеально подходит для обработки потоковых данных с вложенной структурой.

-   **Стек (`context_stack`):** В стеке хранятся объекты, представляющие текущий уровень иерархии. Например: `[Warehouse(name='Склад 1'), ProductGroup(name='Пиво')]`.
-   **Конечный автомат:** Парсер проходит по строкам и, в зависимости от типа распознанной строки, выполняет одно из действий:
    -   **Найдена строка-заголовок (e.g., "Склад"):** В стек добавляется новый объект контекста.
    -   **Найдена строка данных:** К данным этой строки добавляется информация из текущего контекста в стеке.
    -   **Найдена строка-итог:** Верхний элемент контекста удаляется из стека, что означает выход на уровень выше.

Такая модель позволяет надежно "протягивать" контекст от родительских сущностей к дочерним строкам данных, даже если они разделены десятками других строк.

### Alternatives considered (Рассмотренные альтернативы)
-   **Рекурсивный парсинг:** Сложно реализовать для потокового чтения и может привести к переполнению стека вызовов на больших файлах.
-   **Хранение "последнего виденного заголовка":** Простой, но хрупкий подход. Он не справится с многоуровневой вложенностью (например, склад -> группа -> товар) и может привести к ошибкам при наличии нескольких итоговых строк.

## 4. Стратегия обработки типов данных

### Decision (Решение)
Применять строгую и явную обработку для каждого типа данных на этапе парсинга ячейки.

### Rationale (Обоснование)
Автоматическое определение типов данных в `pandas` или других библиотеках может привести к ошибкам (например, `float` вместо `Decimal`, неверный формат даты). Явное преобразование обеспечивает надежность.

-   **Даты (`datetime`):**
    -   `openpyxl` корректно распознает даты, если они сохранены в Excel как даты.
    -   Если даты хранятся как текст, использовать `dateutil.parser.parse` с указанием `dayfirst=True` для корректной обработки форматов `ДД.М.ГГГГ`. Обернуть в `try-except` для обработки некорректных значений.
-   **Числа с плавающей точкой (`float`):**
    -   Для избежания ошибок точности, связанных с двоичным представлением `float`, все денежные значения и точные количества следует немедленно преобразовывать в `Decimal`.
    -   Читать значение ячейки и передавать его в конструктор `Decimal` как строку: `Decimal(str(cell.value))`.
-   **Пустые значения (`None`/`null`):**
    -   Явно проверять `cell.value is None`.
    -   В зависимости от семантики колонки, преобразовывать `None` в `Decimal('0')` для числовых полей (количество, сумма) или оставлять `None` для текстовых полей (описание, артикул). Это предотвращает ошибки `TypeError` при дальнейших математических операциях.

### Alternatives considered (Рассмотренные альтернативы)
-   **Полагаться на автоматическое определение типов:** Как упомянуто, это рискованно и может привести к потере точности или неверной интерпретации данных.
-   **Преобразование типов после парсинга:** Менее эффективно и может быть сложнее, так как исходная информация о типе ячейки в Excel уже будет утеряна. Лучше обрабатывать типы "на лету" во время итерации.

## 5. Lessons Learned / Анти-паттерны

Этот раздел предназначен для накопления знаний и фиксации проблем, выявленных в ходе разработки и эксплуатации парсера.

-   **Анти-паттерн: Неявное преобразование типов.** Полагаться на автоматическое определение типов в `pandas` или других библиотеках рискованно. Это может привести к потере точности (`float` вместо `Decimal`) или неверной интерпретации дат.
    -   **Решение:** Всегда выполнять явное и строгое преобразование типов на этапе парсинга ячейки.

-   **Проблема производительности:** При работе с очень большими файлами (>100 МБ) итеративное чтение строк может замедляться, если внутри цикла выполняется слишком много сложных операций.
    -   **Решение:** Максимально упростить логику внутри цикла парсинга. Сложные вычисления и агрегации выносить за его пределы, если это возможно. Профилировать код для выявления узких мест.

### Типовые ошибки 1С-отчётов

-   **"Схлопнутые" даты:** Excel может отображать `ДД.ММ.ГГГГ ЧЧ:ММ` как `ДД.ММ.ГГГ`, теряя время. Парсер должен быть готов к этому и, если возможно, обрабатывать оба формата.
-   **Текстовые артефакты в числовых полях:** Вместо `0` могут встречаться прочерки (`-`) или пустые строки. Преобразование в `Decimal` должно это учитывать.
-   **Скрытые символы:** Ячейки могут содержать непечатаемые символы или лишние пробелы (`' Товар '` вместо `'Товар'`). Необходимо применять `.strip()` ко всем текстовым значениям.
-   **Неконсистентные названия:** Один и тот же товар или склад может иметь незначительно отличающиеся названия в разных отчетах. Это проблема уровня нормализации данных, но парсер должен быть к этому устойчив.