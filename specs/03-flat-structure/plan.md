# План реализации: Рефакторинг проекта для расчёта усушки и учёта по партиям

## Objective (Цель)
Рефакторинг проекта `shield_ai_v2` для реализации функциональности расчёта усушки и учёта по партиям, с акцентом на упрощённый импорт данных, расчёт усушки, аудит остатков и экспорт результатов в различных форматах.

## Context (Контекст)
Данный план основан на спецификации функции: [`specs/03-flat-structure/spec.md`](specs/03-flat-structure/spec.md), которая была уточнена в ходе сессии 2025-11-15.

## Acceptance Criteria (Критерии приемки)
Критерии приемки подробно описаны в разделе "Критерии успеха" спецификации [`specs/03-flat-structure/spec.md`](specs/03-flat-structure/spec.md).

## Expected Artifact (Ожидаемый артефакт)
Ожидаемым артефактом будет обновленный проект `shield_ai_v2` с реализованной функциональностью, соответствующей спецификации, а также набор юнит-тестов и документация.

## Constraints (Ограничения)
Ограничения и требования подробно описаны в разделе "Требования" спецификации [`specs/03-flat-structure/spec.md`](specs/03-flat-structure/spec.md). Особое внимание уделяется:
- Отсутствию сложной логики FIFO и пересортицы.
- Обработке ошибок при импорте данных (дубликаты, некорректные даты, отсутствующие/нулевые значения).
- Обработке больших объемов данных с предупреждением о производительности.
- Использованию сторонней библиотеки для логирования (Loguru).
- Сбору метрик производительности.
- Аудиту доступа к данным и изменений.
- Использованию `dataclasses` и `TypedDict` для структурирования данных.
- Синхронному коду без `async/await`.

## Detailed Plan (Детальный план)

### Фаза 1: Подготовка и настройка
1.  **Настройка окружения:**
    *   Убедиться, что Python 3.12 и виртуальное окружение настроены.
    *   Установить необходимые зависимости (pandas, openpyxl, Loguru и т.д.).
2.  **Структура проекта:**
    *   Проверить текущую структуру проекта на соответствие слоям: `domain`, `application`, `infrastructure`, `presentation`.
    *   При необходимости, создать или реорганизовать директории.

### Фаза 2: Реализация импорта данных (Пользовательская история 1)
1.  **Разработка парсера Excel-отчётов:**
    *   Создать модуль в `infrastructure/parsers` для чтения Excel-файлов.
    *   Реализовать функцию, которая преобразует данные из Excel в плоскую таблицу (DataFrame или список TypedDict).
    *   Обеспечить валидацию данных:
        *   Проверка на дубликаты и некорректные даты: выдавать ошибку и останавливать импорт.
        *   Проверка на отсутствующие/нулевые значения в критических полях: выдавать ошибку и останавливать импорт.
    *   Обеспечить корректное преобразование типов данных: "остаток" и "количество" в числа, "дата" в дату, остальные в строки.
2.  **Интеграция парсера в `application/use_cases`:**
    *   Создать use-case для импорта данных, который будет использовать разработанный парсер.
3.  **Unit-тесты для парсера и use-case:**
    *   Написать тесты для проверки корректности импорта, обработки ошибок и преобразования типов данных.

### Фаза 3: Реализация расчёта усушки (Пользовательская история 2)
1.  **Разработка логики расчёта усушки:**
    *   Создать модуль в `domain/shrinkage` для реализации упрощённой логики расчёта усушки.
    *   Функция должна принимать плоскую таблицу данных и возвращать результаты расчёта усушки.
    *   Обработка больших объемов данных: реализовать механизм предупреждения о возможном снижении производительности.
2.  **Интеграция логики расчёта в `application/use_cases`:**
    *   Создать use-case для расчёта усушки, который будет использовать разработанную логику.
3.  **Unit-тесты для логики расчёта и use-case:**
    *   Написать тесты для проверки корректности расчётов усушки, включая граничные случаи (отрицательные остатки).

### Фаза 4: Реализация аудита и проверки остатков (Пользовательская история 3)
1.  **Разработка логики аудита:**
    *   Создать модуль в `application/use_cases` для аудита остатков.
    *   Реализовать функции для выявления отрицательных остатков и подозрительных движений с использованием pandas-операций.
    *   Функции должны возвращать отчёты для анализа.
2.  **Unit-тесты для логики аудита:**
    *   Написать тесты для проверки корректности выявления отрицательных остатков и подозрительных движений.

### Фаза 5: Реализация экспорта и отчётов (Пользовательская история 4)
1.  **Разработка экспортеров:**
    *   Создать модули в `infrastructure/exporters` для экспорта данных в JSON, Markdown и SQLite.
    *   Каждый экспортер должен принимать результаты расчётов и сохранять их в соответствующем формате.
2.  **Интеграция экспортеров в `application/use_cases`:**
    *   Создать use-case для экспорта результатов, который будет использовать разработанные экспортеры.
3.  **Unit-тесты для экспортеров и use-case:**
    *   Написать тесты для проверки корректности экспорта в различные форматы.

### Фаза 6: Общие требования и нефункциональные аспекты
1.  **Типизация (MyPy strict):**
    *   Обеспечить покрытие всего кода строгой типизацией.
2.  **Unit-тесты:**
    *   Достичь покрытия юнит-тестами не менее 80% общего кода и 95% для слоёв `domain` и `application`.
3.  **Логирование:**
    *   Интегрировать библиотеку Loguru для логирования событий системы.
    *   Настроить логирование для сбора метрик производительности (время импорта, время расчёта, количество обработанных записей).
4.  **Безопасность:**
    *   Реализовать аудит доступа к данным и изменений.
5.  **Документация:**
    *   Обновить существующую документацию и добавить новую, если требуется.

## Mermaid Diagram (Диаграмма Mermaid)

```mermaid
graph TD
    A[Excel Reports] --> B{Import Data};
    B --> C[Data Validation];
    C --> D[Flat Table (TypedDict/DataFrame)];
    D --> E{Calculate Shrinkage};
    E --> F[Shrinkage Results];
    F --> G{Audit Balances};
    G --> H[Audit Reports];
    F --> I{Export Results};
    H --> I;
    I --> J[JSON/Markdown/SQLite];

    subgraph Data Flow
        B --> C;
        C --> D;
        D --> E;
        E --> F;
        F --> G;
        G --> H;
        F --> I;
        H --> I;
        I --> J;
    end

    subgraph System Layers
        direction LR
        L1[Presentation] --> L2[Application];
        L2 --> L3[Domain];
        L2 --> L4[Infrastructure];
        L3 --> L4;
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px
    style C fill:#bbf,stroke:#333,stroke-width:2px
    style D fill:#bbf,stroke:#333,stroke-width:2px
    style E fill:#bbf,stroke:#333,stroke-width:2px
    style F fill:#bbf,stroke:#333,stroke-width:2px
    style G fill:#bbf,stroke:#333,stroke-width:2px
    style H fill:#bbf,stroke:#333,stroke-width:2px
    style I fill:#bbf,stroke:#333,stroke-width:2px
    style J fill:#f9f,stroke:#333,stroke-width:2px
    style L1 fill:#ccf,stroke:#333,stroke-width:2px
    style L2 fill:#ccf,stroke:#333,stroke-width:2px
    style L3 fill:#ccf,stroke:#333,stroke-width:2px
    style L4 fill:#ccf,stroke:#333,stroke-width:2px