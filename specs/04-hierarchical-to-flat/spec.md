# Спецификация функции: Преобразование иерархических Excel-отчётов в плоские данные

**Функциональная ветка**: `04-hierarchical-to-flat`
**Создано**: 2025-11-15
**Статус**: В работе

## 1. Входные данные

Функция принимает на вход Excel-файлы со сложной иерархической структурой, отражающие отчет "Ведомость по партиям номенклатуры". Примеры файлов:
- `data/input/13.10.25-13.10.25 Полный все склады с коррекцией.xlsx`
- `data/input/13.10.2025 все СКЛАДЫ Разливное пиво.xlsx`
- `data/input/горбуша.xlsx`
- `data/input/СКУМБРИЯ.xlsx`

## 2. Общая иерархическая структура и ключевые особенности

Все проанализированные файлы имеют одинаковую иерархическую структуру:

1. **Склад**: Верхний уровень иерархии, представляет собой место хранения товаров.
2.  **Номенклатура (Товар)**: Группа конкретных товаров/продуктов.
3.  **Документ движения**: Транзакция, вызвавшая изменение в остатках (поступление, расход, корректировка и т.д.).
4. **Партия.Дата прихода**: Конкретная партия товара с указанием даты поступления.

**Ключевые особенности структуры (для всех разобранных файлов):**
- Под номенклатурой (товаром) действительно идут блоки документов, а внутри документа — строки движения партии.
- Каждая строка движения содержит сведения о списании или поступлении по определённой партии.
- **Партия создаётся только приходным документом.** Партия — это уникальное сочетание товара и даты (времени) ее приёмки, иногда с номером или внутренним идентификатором. Если `batch_code` пропущен, он должен быть явно восстановлен по контексту из последнего валидного.
- Все последующие операции (расходы, корректировки, возвраты) только "тратят" или "корректируют" уже созданную ранее партию.
- Вся логика обработки движений производится 1С, и ваш парсер не должен по-своему рассчитывать/размещать движения внутри партий: строки идут РОВНО в порядке, в котором возвращены в выгрузке отчёта, сохранением всех `batch_code`/`batch_date`/`doc_type`.

## 3. Уникальные иерархические уровни и вариации

### 3.1. Файл "13.10.25-13.10.25 Полный все склады с коррекцией.xlsx"
- Содержит все склады без фильтрации.
- Включает корректировки, что отражено в названии файла.
- Не имеет дополнительных фильтров.

### 3.2. Файл "13.10.2025 все СКЛАДЫ Разливное пиво.xlsx"
- Дополнительный уровень фильтрации: "Номенклатура.Базовая единица по классификатору Равно 'л дм3'".
- Включает группу товаров "Разливные напитки" (помимо разливного пива).
- Имеет более широкую категоризацию товаров.

### 3.3. Файлы "горбуша.xlsx" и "СКУМБРИЯ.xlsx"
- Имеют фильтр по конкретному товару: "Номенклатура Равно 'ГОРБУША Х/К'" или "СКУМБРИЯ Х/К'".
- Включают фильтр по конкретному складу: "Склад Равно 'Монетка рыба (Рыба Дачная )'".
- Отображают только ненулевые движения.
- Специализированный склад для хранения рыбной продукции.

**Примечание:** При дальнейшем увеличении числа категорий товаров, их особенности (ключевые слова, структура) рекомендуется вынести в отдельный конфигурационный файл (например, YAML) для упрощения расширения.

## 4. Типы данных и форматы

Все файлы используют одинаковую структуру столбцов:

-   **A**: Склад/Номенклатура/Документ движения/Партия - текстовые данные.
-   **B**: Пустой столбец (вспомогательный).
-   **C**: Параметры отчета, фильтры, даты - смешанные типы.
-   **D**: Пустой столбец (вспомогательный).
-   **E**: Начальный остаток (для файлов с разливным пивом).
-   **F**: Начальный остаток количества.
-   **G**: Приход количества.
-   **H**: Расход количества.

Все числовые данные представлены в формате с плавающей точкой с высокой точностью (до 3-4 знаков после запятой), что важно для учета весовых товаров и напитков.

## 5. Итоговые требования к парсеру/спецификации

### 5.1. Контекст
- Всегда "тянуть" вниз актуальный контекст товара, документа, партии (дата и номер приема).
- Если какая-либо из сущностей пропущена в строке движения, брать её из предыдущего блока, либо логировать как ошибку и пропускать строку, если восстановление невозможно.

**Критерии приемки для извлечения контекста:**
- **AC-1.1**: Парсер должен корректно извлекать и "тянуть вниз" значения `warehouse`, `product`, `doc_type`, `doc_date` для каждой строки движения.
- **AC-1.2**: При обнаружении новой сущности (склада, товара, документа) парсер должен обновлять контекст и применять его ко всем последующим строкам до следующего изменения.
- **AC-1.3**: Если в строке движения отсутствует один из ключевых контекстных параметров (`warehouse`, `product`, `batch_code`, `batch_date`), парсер должен:
  - Попытаться восстановить значение из предыдущего блока с валидным контекстом
  - Если восстановление невозможно, строка должна быть исключена и записана в лог ошибок с указанием координаты строки и причины
- **AC-1.4**: Восстановление контекста должно происходить синхронно, без использования асинхронных операций.
- **AC-1.5**: Пример входных данных: строка 15 содержит "Склад: Основной", строка 16 содержит "Товар: Пиво", строка 17-20 - строки движения без указания склада и товара. Ожидаемый результат: все строки 17-20 должны содержать `warehouse: "Основной"` и `product: "Пиво"`.
- **AC-1.6**: Пример обработки ошибки: строка 25 содержит движение без указания `product`, при этом выше в блоке нет валидного значения. Ожидаемый результат: строка исключена из обработки, запись в лог: "Missing product context at row 25".

### 5.2. Flat-структура строки
- Каждая строка движения (output-flat) содержит: `warehouse`, `group`, `product`, `batch_code`, `batch_date`, `doc_type`, `doc_date`, `qty_begin`, `qty_in`, `qty_out`, `qty_end`, `unit`, `comment`.
- `batch_code` & `batch_date` тянутся только от прихода (создания партии), расход — только списывает из существующей партии, все движения (в т.ч. возвраты/коррекции) указывают на уже существующую партию в отчёте.

**Критерии приемки для восстановления кода пакета:**
- **AC-2.1**: Если `batch_code` отсутствует в строке документа движения, парсер должен восстановить его из контекста последнего валидного приходного документа для данного товара.
- **AC-2.2**: Если `batch_date` отсутствует, но `batch_code` присутствует, парсер должен попытаться восстановить `batch_date` из контекста той же партии.
- **AC-2.3**: Если ни `batch_code`, ни `batch_date` не могут быть восстановлены, строка должна быть исключена и записана в лог ошибок.
- **AC-2.4**: Парсер должен корректно различать приходные и расходные документы для правильного восстановления контекста партии.
- **AC-2.5**: Восстановление `batch_code` и `batch_date` должно учитывать иерархию: склад → товар → документ → партия.
- **AC-2.6**: Пример входных данных: строка 30 содержит приход с `batch_code: "B001"` и `batch_date: "2025-01-15"`, строка 31-33 содержат расходы без `batch_code`. Ожидаемый результат: строки 31-33 должны содержать `batch_code: "B001"` и `batch_date: "2025-01-15"`.
- **AC-2.7**: Пример обработки ошибки: строка 40 содержит расход с `batch_code: "B002"`, но приходной документ с этим кодом не найден в предыдущих строках для данного товара. Ожидаемый результат: строка исключена из обработки, запись в лог: "Cannot find matching incoming batch for batch_code 'B002' at row 40".

### 5.3. Признаки, шаблоны, автоматическое определение
- Парсер обязан использовать паттерны для отделения заголовков, итогов, разделительных строк.
- Проверять разные шаблоны дат (с/без времени).
- Автоматически определять специфику структуры (рыба, весовые, вода, "разливное"), если структура отличается от базовой, — по фильтрам, названиям, уникальным словам.

### 5.4. Запрет вторичной логики
- Не делать никакую вторичную логику партий, FIFO, агрегацию остатков — только flat-конвертация!
- Если последовательность движения в отчёте порвана или `batch_code`/`dates` неочевидны, оставлять строку с `error flag/log`.
- Парсер гарантирует сохранение движений по партиям ровно как они получены в отчёте 1С, без повторного пересчитывания или корректировки. Основной принцип — любой расход или коррекция всегда привязаны к партии с `batch_code`+`batch_date`, созданной приходным документом.
- Все технические или некорректные строки отбрасываются/логируются; при невозможности восстановить контекст строка исключается с пояснением причины.
- Любые попытки автоматического углубленного анализа партий (реализация FIFO либо перекиньте остатки) категорически запрещены. Ваш единственный источник истины — структура выгруженная из 1С-отчёта.
- Автоматическое определение структуры входного файла
- Если файл — "рыба" или "разливное" — автоопределение признаков (например, по первым строкам, ключевым словам или сочетанию столбцов/фильтров).

## 6. Обработка ошибок и edge-case
- Отдельно логировать:
    - Строки с пропущенным `batch_code`/`batch_date`, которые не удалось восстановить
    - Все некорректные структуры (двойной заголовок, строка "итого", строки с разрывом контекста)
    - Строки, в которых нарушен expected порядок (например, расход/коррекция идет до первого прихода партии)
    - Строки с невосстановимым отсутствием `batch_date` или `doc_date` (после попытки взять из контекста). Такие строки должны быть отброшены и занесены в лог ошибок.

### 6.1. Граничные случаи
- Пустые строки/ячейки: Присутствуют в начале каждого файла (строки 1-3 и 6-7), встречаются в середине данных как разделители. Ячейки с нулевыми значениями могут быть как пустыми, так и содержать 0.
- Смешанные типы в столбце A: В столбце A объединены разные уровни иерархии (Склад, Номенклатура, Документ, Партия). Текстовые строки чередуются с датами и названиями документов. Требуется логика для определения типа записи по контексту.
- Дублирующиеся заголовки: Заголовки повторяются в строках 2 и 8-10, что может вызвать путаницу при парсинге. Необходима предварительная обработка для идентификации настоящих данных.
- Отрицательные значения: Присутствуют в столбцах F (начальный остаток), G (приход), H (расход). Отрицательные значения могут указывать на корректировки, возвраты или оприходование излишков. Особенно заметны в файле с коррекциями.
- Перенос партии (пересортица, явно внесённая корректировка партии в отчёте): Требуется логировать, но не мешать расчёту.

## 7. Предложения по унификации парсинга

### 7.1. Механизм "контекстного стека"
- Для каждой строки движения значения всех вышестоящих уровней (склад, товар, партия, документ) ДОЛЖНЫ "тянуться вниз" до тех пор, пока не встретится новая их явная установка.
- **Логика прогонки контекста**: "На каждом уровне иерархии парсер ДОЛЖЕН тянуть актуальное значение вверх по дереву (от последней валидной строки), если оно не задано явно."

### 7.2. Структура выходных Flat-записей (FlatRecord)

См. определение FlatRecord в [`data-model.md`](data-model.md), которое является каноническим источником для этой сущности.

### 7.3. Требования к логам и обработке ошибок

- **Логи ошибок**: "Все некорректные или пропущенные значения ДОЛЖНЫ быть записаны в отдельный лог с координатой исходной строки и причиной отбраковки."
- Логирование ДОЛЖНО включать: "context lost", "wrong parse", "duplicate header", "missing batch_code/batch_date" с указанием координат исходной строки для отладки и аудита.

### 7.4. Контроль консистентности Batch Code и Batch Date

- Если парсится `batch_code`, но `batch_date` отсутствует, парсер ДОЛЖЕН либо логировать это как ошибку, либо брать `batch_date` из контекста (обязательное правило для парсера).

### 7.5. Автоматическое определение структуры входного файла
- Если входной файл является "рыбой" или "разливным", система ДОЛЖНА автоматически определять признаки (например, по первым строкам, ключевым словам или сочетанию столбцов/фильтров).

---

## 9.6 Требования для корректного расчёта усушки (Shrinkage Accounting)

1.  **Ограничения периода расчёта усушки:**
    *   Корректный расчёт усушки возможен только для интервала между двумя последовательными инвентаризациями: начальная инвентаризация задаёт `qty_begin`, финальная — `qty_end`. Если инвентаризация была один раз — расчёт ведётся от неё до конца периода.
2. **Формула расчёта усушки для каждой партии:**
    *   Для каждой уникальной партии (`warehouse`, `product`, `batch_code`, `batch_date`) усушка вычисляется за период между инвентаризациями формулой:
        $$
        shrinkage = qty\_in + qty\_begin - qty\_out - qty\_end
        $$
        где `qty_end` — остаток по партии после конечной инвентаризации.
3.  **Соответствие исходной логике списания:**
    *   Логика списания партий уже реализована при формировании движений в 1С-отчёте. Flat-парсер ничего не 'размешивает' внутри одной партии — а просто фиксирует движения между инвентаризациями и фиксирует фактическую усушку, выявленную физической ревизией (инвентаризацией), без какой-либо дополнительной обработки или пересчёта.
4. **Работа с "минусом" и техническим разбросом:**
    *   Если между инвентаризациями по партии есть отрицательные остатки, пересортицы или другие отклонения, они не исправляются парсером — они отображаются в отчёте. Только финальный `qty_end` после инвентаризации определяет, сколько реально осталось, то есть сколько усушено.
5.  **Контроль контекста:**
    *   Все строки без явно восстановленного `batch_code` (или других обязательных идентификаторов партии) — выбрасываются или выносятся в error-log и в расчетах не участвуют.
6. **Требование к тестам и валидации:**
    *   Результаты автоматического расчёта усушки на типовых отчетах сверяются с результатами ручной сверки на примерах с заранее известной усушкой ('golden master' для партии).
7.  **Инвентаризация как маркер пограничного остатка:**
    *   Инвентаризация как в начале, так и в конце периода 'обнуляет' все технические расхождения и определяет точку отсчёта для расчёта усушки — аналитика и E2E тесты должны базироваться на этом правиле.
8.  **В вывод flat-отчёта для анализа усушки обязательно включать строки инвентаризации как отдельные виды движений, не смешивать их с обычным расходом/приходом.

**Финальный акцент:**
- Парсер должен делать только точное плоское отображение факта движения из 1С-отчёта согласно видимой последовательности, без какой-либо логики по пересчёту FIFO, агрегации, соединения или восстановления остатков партий. Вся обработка данных должна быть синхронной без дополнительной логики.